{:title "Clojure vs. Racket - мои наблюдения"
 :layout :post
 :tags  ["clojure" "lisp" "racket" "thoughts"]}

Недавно потянуло меня подосвежить в памяти ЛИСП, в качестве учебного пособия и источника игрушечных проектов я без колебаний выбрал LoL. А вот над тем какой диалект выбрать призадумался на пару дней. Вообще сама ситуация довольно примечательна, ЛИСП насколько я понимаю сейчас является единственным языком с несколькими совершенно живыми и здравствующими диалектами. Встраиваемые я сразу отбросил, но и вполне себе самостоятельных осталось порядочно.

В финал вышли два - [Clojure](http://clojure.org/) и [Racket](http://racket-lang.org/). Common Lisp я отбросил так как в нём многовато на мой вкус специальных форм, макросов и прочих интересных вещей, мне он показался достаточно непоследовательным. Для двух финалистов есть [известное и по сути очень хорошее сравнение](http://programming-puzzler.blogspot.com/2010/08/racket-vs-clojure.html). Его вывод достаточно однозначен - на практике программировать на Clojure гораздо удобнее, а для учебных целей у диалектов паритет. Однако пост от 2010 года и часть данных там устарели. Ниже я перечислю все устаревшие моменты в том посте ну и приведу пару фактов которые склонили мой выбор в пользу ракеты.

Первый довод автора - отсутствие общих интерфейсов у разных структур данных, в частности списка и вектора. На сколько я могу судить эта проблема решена. Во-первых введено понятие [последовательности](http://docs.racket-lang.org/reference/sequences.html) и определён ряд удобных [форм и функкций](http://docs.racket-lang.org/guide/for.html) для работы с ними. Кроме того добавлена наконец поддержка [абстрактных типов данных](http://docs.racket-lang.org/reference/struct-generics.html). Кажется полностью аналогична [протоколам](http://clojure.org/protocols) из Clojure.

Вторая проблема: не консистентная работа со словарями. Она исправлена во-первых ведением [протокола для словарей](http://docs.racket-lang.org/reference/dicts.html), поддерживаемого из коробки хеш-таблицами и списками пар. Во-вторых богатым семейством функций [in-dict*](http://docs.racket-lang.org/reference/dicts.html#%28def._%28%28lib._racket%2Fdict..rkt%29._in-dict%29%29) по преобразованию словарей в последовательности.

Последнее что не понравилось автору - отсутствие ленивых списков или потоков. Она тоже исправлена на настоящий момент - есть неплохая на мой взгляд [библиотека потоков](http://docs.racket-lang.org/reference/streams.html), хорошо прилегающая в нужных местах к последовательностям и словарям.

В принципе я согласен с тем что сейчас Clojure ближе к промышленности. Но связано это в основном с количество активных фанатов которые активно её рекламируют и, надеюсь, репортят баги.

Почему я в итоге выбрал Racket? Буквально две причины. Во-первых в Clojure слишком много на мой вкус синтаксических конструкций. Да да, ЛИСП с избытком конструкций, куда мир катится? Куча каких-то скобочек, шапочек, двоеточий и стрелочек... Всякие навороты вроде ключевых слов очень активно используются стандартной библиотекой. Вторая - JVM. Сейчас я уж слишком привязан к ней, надо как-то расширять кругозор.
