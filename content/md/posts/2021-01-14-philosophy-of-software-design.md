{:title "A Philosophy of Software Design"
 :layout :post
 :tags  ["books" "programming"]
 :draft? true}

С удовольствие и легко прочитал "A Philosophy of Software Design". Отличная, коротка и по делу книга. Возможно и не перевернёт жизнь 10+ лет программиста, но определённо поможет яснее сформулировать некоторые идеи. Кроме того можно советовать начинающим профессионально программировать как краткое введение в вопрос "как не похоронить себя под горой кода?".

Книга начинается тем что пытается определить сложность кода и научиться её видеть. Также автор немного философствует о причинах её появления и накопления. В общем вопрос рассматривается от сравнительно простых и конкретных вещей к более абстрактным. Рассматривается какие альтернативы открываются при дизайне отдельных модулей, их взаимодействии, выстраивании в уровни. Вводит понятие интерфейса и как его можно строить отдельно от реализации, рассматривает обработку ошибок. Очень существенная часть книги посвящена комментариям. Отдельно обсуждается вопрос комментарии vs. именование. В конце обсуждаются вопросы последовательности и очевидности в больших кодовых базах и как они сочетаются с желанием эволюционировать код и продукт.

Почти в каждой главе есть раздел "Как не зайти слишком далеко". Очень-очень важная штука которой отчаянно не хватает другим книгам схожей тематики. Особенно ценна для начинающих.

По тексту разбросаны удобные спецсекции: принципы и красные флаги. Первые - краткие формулировки содержания главы, легко помещающийся и пригодный для быстро коммуникации гайдлайн. Вторые - признак грядущей проблемы с поддержкой кода, заметив который стоит еще немного подумать. Они разбросаны по тексту и удобно повторены в приложении в конце.

Мне очень понравился выбранный уровень конкретики, модно сказать детализации в книге. С одной стороны обсуждаются общие концепции вроде "интерфейс", "можуль", "зависимость". С другой стороны примеры в основном в виде классов на джаве. Содержимое можно примерить на задачу и если впервые в жизни режешь простыню кода на процедуры и если собираешь мега-проект по принципам SOA. Нет длинющих, трудно запоминаемых и неизбежно противоречивых списков правил так - хорошо а эдак - плохо.

Не хватает важных, по моему мнению, аспектов дизайна. Во-первых факторов коллаборации. Как организовывать разделение кода не только по функциям и зависимостям, но и по времени разработки и потокам работ? Как транслировать и отслеживать изменения архитектурных решений? Во-вторых не хватает обсуждения вопросов конфигурации и развертывания. Как проверять параметры окружения и как реагировать на несоответствие ожиданиям? Какие настройки стоит фиксировать во время сборки а какие оставлять на рантайм? Как организовать включение-выключение функционала на этапе сборки или в рантайме без изменений кодовой базы? В-третьих это сторонние библиотеки. Когда стоит искать внешнее решение? А когда пора от него отказываться? Зависимость от кода против зависимости от бинарников.

Все эти критичные вопросы дизайна пропущены. В защиту автора стоит заметить что студенческие и академические проекты редко в них упираются.

Selected ideas:
1. Module deepness
2. Design out of existence
3. Doc close to code in placement and far in level
