{:title "A Philosophy of Software Design"
 :layout :post
 :tags  ["books" "programming"]}

Легко и с удовольствием прочитал "A Philosophy of Software Design". Автор - преподаватель и исследователь, не кодер от сохи, но и не консалтант. В начале честно признаётся что основа выводов наблюдение за студенческими проектами длительностью 1-2 семестра и парой исследовательских долгостроев.

Книга начинается тем что пытается определить сложность кода и научиться её видеть. Также автор немного философствует о причинах её появления и накопления. В общем рассматривает вопрос от сравнительно простых и конкретных вещей к более абстрактным. Рассказывает какие альтернативы открываются при дизайне отдельных модулей, их взаимодействии, выстраивании в уровни. Вводит понятие интерфейса и как его можно строить отдельно от реализации, рассматривает обработку ошибок. Очень существенная часть книги посвящена комментариям. Отдельно обсуждается вопрос комментарии vs. именование. В конце разговор о последовательности и очевидности в больших кодовых базах и том как они сочетаются с желанием менять код и продукт.

Почти в каждой главе есть раздел "Как не зайти слишком далеко". Очень-очень важная штука которой отчаянно не хватает другим книгам схожей тематики. Особенно ценна для начинающих.

По тексту разбросаны удобные спецсекции: принципы и красные флаги. Первые - краткие формулировки содержания главы, упакованные в пару предложений и пригодные для быстрого коммуникации гайдлайны. Вторые - признаки грядущей проблемы с поддержкой кода, заметив которые стоит еще немного подумать. Они разбросаны по тексту и удобно повторены в приложении в конце.

Мне очень понравились выбранные уровни конкретики и детализации в книге. С одной стороны обсуждаются общие концепции вроде "интерфейс", "модуль", "зависимость". С другой стороны примеры в основном в виде классов на джаве. Содержимое можно примерить на задачу и если впервые в жизни нарезаешь простыню кода на процедуры и если собираешь мега-проект по принципам SOA. Нет длиннющих, трудно запоминаемых и неизбежно противоречивых списков правил так - хорошо а эдак - плохо.

Из минусов - пропущены важные, по моему мнению, аспекты дизайна. Во-первых коллаборация. Как организовывать разделение кода по времени и потокам работ? Как транслировать и отслеживать изменения архитектурных решений? Во-вторых конфигурации и развертывания. Как проверять параметры окружения и как реагировать на несоответствия? Какие настройки стоит фиксировать во время сборки а какие оставлять на рантайм? В-третьих использования стороннего кода. Когда стоит искать готовую библиотеку? А когда пора от неё отказываться? Зависимость от кода против зависимости от бинарников. Но наверно студенческие и академические проекты редко в них упираются.

В общем отличная, коротка и по делу книга. Возможно и не перевернёт жизнь 10+ лет программиста, но определённо поможет яснее сформулировать некоторые идеи. Кроме того можно советовать начинающим профессионально программировать как краткое введение в вопрос "как не похоронить себя под горой кода?".
