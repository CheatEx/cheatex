{:title "Странный гайд по исключениям от гуавы"
 :layout :post
 :tags  ["java", "exceptions" "TG repost"]}

Наткнулся тут на [гайд по пользованию исключениями в Guava](https://github.com/google/guava/wiki/ConditionalFailuresExplained), и видимо в джавовских проектах гугла.

Первое что бросается в глаза Rationale пропущен. Второе - 6 вариантов ответа для фундаментального вопроса это реально дохера. Если вчитаться тоже есть вопросы.

Мне показалось что основная проблема которая решается применением этой конвенции - поиск виноватых. Краткое изложение в табличке целиком про кто "messed up".

Не понятно зачем сюда втянут exceptional result. Типа контракт штуки такой, ожидаемое поведение. Test assertion его частный случай, ничего требующего выделения отдельного пункта не сказано. Дальше в табличке предлагают `AssertionError` для него, видиом чтобы по ошибке не ловить падение теста вместо своего исключения. Но это стоило прояснять явно и в формате примечания к exceptional result.

_Precondition_ check важный частный случай, всё-таки это ситуация когда у кода нет в принципе возможности сделать задуманое. Можно согласиться.

_Assertion_ - понятно, поддерживаю.

_Verification check_ пункт про поиск виноватых и пинг-понг. Никакой разницы почему вмерло нет, нарушено ожидание, действуем по плану assertion. А тут добавлен отдельный пункт и класс с утилитами под него.

_Impossible-condition_ check вообще не понимаю зачем нужен, всё еще assertion.

В этой системе есть проблема: легко ловить что-то тебе не предназначенное. Если есть контракты с исключениями то в код который их использует может приехать и _precondition check_ и _verification check_. Чтобы работало ко всей конструкции надо еще добавлять правило в духе "не ловим `Exception` и `RuntimeException` в прикладном коде". И правило какой код уже можно считать системным. А потом еще правило про catch который на самом деле finally. Ну вы поняли.

Вывод: там тоже всё плохо. На Java надо писать без ошибок или не писать вообще.
