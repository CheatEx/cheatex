{:title "Про Nix"
 :layout :post
 :tags  ["programming" "tools" "nix"]
 :draft? true}

Пару лет уже почитываю про никс, но только после последнего fprog митапа собрался наконец поставить и поиграться. Практика конечно отличается от теории. Хочу поделиться некоторыми наблюдениями. Я не буду тут рассказывать концепцию, по ней очень много материалов как текстовых так и видео. Посоветую [доклад от Franz Pletz](https://www.youtube.com/watch?v=b1UoMevTgBw) который кмк максимально раскрывает вопрос "зачем?" и даёт необходимый минимум инфы по реализации.

Ну это еще один гит. В смысле весь интерфейс и практика использования построены вокруг того как он внутри устроен. Юзабельных абстракций над потрохами и сборкой конкретных пакетов в репе дистрибутива почти нет. Хочешь хоть что-то получить - будь добр напиши кусок кода на одноимённом языке, и гугли какой из 5 команд его скормить. С командами кстати тот же адок. Судя по всему сейчас идёт уже второй проход депрекейтов и перенарезки функций между консольными утилитами. Какие-то туториалы и примеры вообще не работают, какие-то активно пишут ворнинги.

Сборка каждого семейства пакетов - это реально свой код, свой особенный API, без доки и с нетривиально локализуемыми исходниками. Из плюсов - язык простой и если исходники всё-таки нашёл обычно догадаться как подложить нужную версию исходников или флаги компилятора не сложно.

Как и с гитом после того как перестаёшь претендовать на то чтобы инструмент сам решал какие-то твои задачи и начинаешь копать потроха всё становится на свои места. Вместе с `direnv` он действительно решает вопрос с проектным окружением и позволяет вести несколько проектов разных версиях одной и той же экосистемы. Интересно, есть ли у этого будущее во взрослой промышленности, где народ не воспринимает познание прекрасного как самоцель?

В общем иметь дело с языками типа C, где зависимостей не много и инструменты их подцепляют из системы а не пытаются резолвить сами довольно приятно.

А вот как паковать сборки языков скриптового типа я пока не понял. Т.е. тех где зависимостей десятки а то и сотни и они резолвятся экосистемными инструментами как часть самой сборки (сюда попадает и Java). Похоже что это решается через зарезолвить зависимости "как принято" раз а потом их бинари оптом заморозить как один большой пакет-зависимость, но это не точно, разбираюсь.

В общем неприятные аспекты у Nix есть, но это отличная альтернатива подходу "используем docker и как переносимый пакетный менеджер".
