{:title "Про Nix"
 :layout :post
 :tags  ["programming" "tools" "nix"]}

Пару лет уже почитываю про никс, но только после последнего fprog митапа собрался наконец поставить и поиграться. Хочу поделиться некоторыми наблюдениями. Я не буду тут рассказывать концепцию, по ней очень много материалов как текстовых так и видео. Посоветую [доклад от Franz Pletz](https://www.youtube.com/watch?v=b1UoMevTgBw) который кмк максимально раскрывает вопрос "зачем?" и даёт необходимый минимум инфы по реализации. Решившим разобраться и копнуть внутрь можно читать серию статей [Nix Pills](https://nixos.org/guides/nix-pills).

Если кратко - это еще один гит. В смысле весь интерфейс и практика использования построены вокруг того как он внутри устроен. Юзабельных абстракций над потрохами и сборкой конкретных пакетов в репе дистрибутива почти нет. Хочешь хоть что-то получить - будь добр напиши кусок кода на одноимённом языке, и гугли какой из 5 команд его скормить. С командами кстати тот же адок. Судя по всему сейчас идёт уже второй проход депрекейтов и перенарезки функций между консольными утилитами. Какие-то туториалы и примеры вообще не работают, какие-то сыпят ворнингами.

Сборка каждого семейства пакетов - это реально свой код, свой особенный API, без доки и с нетривиально локализуемыми исходниками. Из плюсов - язык простой и если исходники всё-таки нашёл обычно догадаться как подложить нужную версию исходников или флаги компилятора не сложно.

Если говорить о сборке пакетов, то как иметь дело с языками типа C, где зависимостей не много и все можно слинковать статически в общем понятно. А как паковать сборки языков скриптового типа я пока не понял. Скриптовыми я называю те где зависимостей десятки-сотни и они резолвятся специальными инструментами в процессе сборки (сюда попадает и Java). Похоже что это решается через зарезолвить зависимости "как принято" раз а потом их бинари оптом заморозить как один большой пакет-зависимость. Но это не точно, разбираюсь.

Если говорить про воспроизводимые и переносимые окружения для разработки то вместе с `direnv` он действительно решает этот вопрос. Позволяет вести несколько проектов разных в версиях одной и той же экосистемы на одной машине.

Как и с гитом, после того как перестаёшь претендовать на то чтобы инструмент сам решал какие-то твои задачи и начинаешь копать потроха всё становится на свои места. Непонятно есть ли у этого будущее во взрослой промышленности, где народ не воспринимает познание прекрасного как самоцель. В общем неприятные аспекты у Nix есть, но это отличная альтернатива подходу "используем docker как переносимый пакетный менеджер".
