{:title "Fire and motion 2019"
 :layout :post
 :tags  ["thoughts" "TG repost"]}

 Немного реалий андроид программирования.

Сегодня понадобилось сделать тест работающий непосредственно на устройстве. (Никогда, слышите никогда не вводите зависимости между дествительно важным функционалом и любыми нативными API).

Сделал по гайду. Впилил зависимость `androidx.test:runner:1.1.0`, повесил `@RunWith(AndroidJUnit4.class)` на тест. Тут мне говорят ахтунг, 1.1.0 устарел, надо на 1.1.1 обновляться. Обновился, иду в код. Там снова ахтунг, `androidx.test.runner.AndroidJUnit4` устарел, надо `androidx.test.ext.junit.runners.AndroidJUnit4`. Поправил, одна беда - такого класса нет. Иду на SO, там советуют `androidx.test.ext:junit:1.1.0`. Ну я то стаинг ап-ту-дейт, сразу на 1.1.1 поправил. Билдим - всё наёбывается, `androidx.test.ext:junit:1.1.1` отсутсвует. Вдох, выдох, всё откатываем на 1.1.0. Билдим, билдицо. Запускаем тест - всё наёбывается, 2 экрана ошибок. Ещё глубже вдох, помедленнее выдох чтоб в голову не дало. Возвращаем аннотацию `androidx.test.runner.AndroidJUnit4`. Работает!!!

А теперь 2 интересные детали. _Deprecation warning_ можно сапреснуть только во всём классе сразу. Gradle _dependency inspection_ нельзя сапреснуть вообще, только выключить полностью.

Интересно, зачем выпускать несовместимое обновление с изменением в 3 числе версии? Зачем рекомендовать миграцию с работающего класса на сломаный? Зачем заставлять делящихся прибылью разработчиков выбирать между кучей нерелевантных ворнингов и риском пропустить критичное изменение?

Классики проясняют [Fire And Motion](https://www.joelonsoftware.com/2002/01/06/fire-and-motion/).
